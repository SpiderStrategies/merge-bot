---
alwaysApply: true
---

# Spider Merge Bot

The Spider Merge Bot automatically merges changes forward across release branches
(e.g., release-5.8.0 → main). When conflicts occur, it creates issues for
developers to resolve.

## ⚠️ CRITICAL: Multi-Invocation Operation

**A single PR's merge chain spans MULTIPLE GitHub Action runs.**

Example: PR #123 conflicts at main
- **Action Run #1**: Creates `merge-forward-pr-123-{release-5.7.1, release-5.8.0}`, conflicts at main
- Developer resolves conflicts, creates PR
- **Action Run #2** (days later): Resumes chain, completes to main, updates ALL releases

**Implications**:
- No in-memory state across invocations
- Must query Git/GitHub for existing branches (can't assume branches are from current run)
- Parse branch names for metadata (PR numbers, targets)
- Handle both "start chain" and "resume chain" scenarios

## Key Concepts

### Branch Types

| Branch Type | Purpose | Updated When |
|-------------|---------|--------------|
| `release-X` | Actual releases, hotfixes | Only after merge-forward chain reaches main |
| `branch-here-release-X` | Safe branching points for developers | Only when commits reach main |
| `merge-forward-pr-<number>-<target>` | Isolated merge chains per PR | During auto-merge process |
| `merge-conflicts-<issue>-...` | Conflict resolution workspace | When conflict detected |

### branch-here Branches

**Critical**: Developers must ALWAYS branch from `branch-here-{version}` branches,
NEVER from `release-{version}` branches.

**Why**: branch-here branches only include commits that have successfully merged
**all the way to main**. This prevents developers from inheriting merge conflicts
from anywhere in the release chain.

**Example**:
- ✅ Branch from: `branch-here-release-5.8.0`
- ❌ Never branch from: `release-5.8.0`

**Important**: The terminal branch (`main`) does NOT have a `branch-here-main` pointer.

**Why**: `branch-here` branches serve as stable snapshots of commits that have
successfully completed the entire merge chain to main. Since `main` itself IS the
final destination and already represents that stable state, a `branch-here-main`
would be redundant. Developers can branch directly from `main`.

### merge-forward Branches

**Purpose**: These branches track each PR's merge chain in isolation, ensuring
developers only see their own conflicts during resolution.

**Format**: `merge-forward-pr-{prNumber}-{targetBranch}`

**Examples**:
- `merge-forward-pr-123-release-5-7-1`
- `merge-forward-pr-123-release-5-8-0`
- `merge-forward-pr-123-main`

**How They Work**:
1. When a PR merges to a release branch, the bot creates an isolated merge chain
2. Each merge-forward branch merges with the corresponding `branch-here` snapshot
3. If conflict occurs, developer resolves in a `merge-conflicts` branch and PRs to the merge-forward branch
4. **When the resolution PR merges, a NEW GitHub Action invocation continues the chain**
5. Only after the entire chain reaches main are release branches updated
6. All merge-forward branches are deleted after successful completion

**Critical**: Steps 1-3 happen in one action invocation, steps 4-6 happen in a DIFFERENT
action invocation (possibly days later). The code must find ALL merge-forward branches
for a PR, not just the ones created in the current run.

### merge-conflicts Branches

**Purpose**: These branches serve as workspaces for developers to resolve conflicts.
They also act as **markers in Git history** to track which commits have unresolved
merge conflicts, preventing branch-here pointers from advancing past them.

**Format**: `merge-conflicts-{issueNumber}-{sourceBranch}-to-{targetBranch}`

**Examples**:
- `merge-conflicts-68586-release-5-8-0-to-main`
- `merge-conflicts-68590-release-5-7-2-to-release-5-8-0`

**How They Work**:
1. Bot creates merge-conflicts branch based on the TARGET's branch-here pointer
2. Developer checks out the branch and merges the PR's progress (previous merge-forward) INTO it
3. Developer resolves conflicts and pushes
4. Developer creates PR from merge-conflicts to the target's merge-forward branch
5. When PR merges, the merge-conflicts branch is deleted
6. Bot continues the merge-forward chain

**Important**: Stale merge-conflicts branches prevent branch-here from advancing
and must be deleted manually if not cleaned up automatically.

## The Core Problem: Conflict Isolation

When multiple PRs have conflicts at the same point in the merge chain, their
changes can get mixed together.

### Scenario Beta (The Problem Case)

1. User A makes a change in `release-5.7.0` that auto-merges to `release-5.8.0`. Conflicts when merging to `main`.
2. User B makes a change in `release-5.7.0` that auto-merges to `release-5.8.0`. Conflicts when merging to `main`.

**Problem**: When User B's commit auto-merges into `release-5.8.0`, that branch
already contains User A's auto-merge commit. If User B's merge-conflicts branch
is based on their auto-merge, User B will see User A's conflicts mixed with their own.

**Goal**: Users should only see their own conflicts.

### How merge-forward Solves This

- User A's chain merges with `branch-here-release-5.8.0` (at commit X)
- User A conflicts at main; `branch-here-release-5.8.0` stays at X
- User B's chain also merges with `branch-here-release-5.8.0` (still at X!)
- User B's chain does NOT contain User A's changes
- Each user only sees their own conflicts

## Merge Direction: Forward, Not Backward

**Key principle**: Always merge from lower versions to higher versions (forward).

### Why Forward Merging Matters

Merging `release-5.8.0` → `main` applies only the PR's commits (few).
Merging `main` → `release-5.8.0` applies all of main's divergent history (thousands).

### Conflict Resolution: Merge PR Progress Forward

Developer merges the previous `merge-forward` branch INTO `merge-conflicts`:

```bash
git checkout merge-conflicts-999-release-5-8-0-to-main  # Based on main
git merge origin/merge-forward-pr-123-release-5-8-0    # PR's progress (few commits)
```

**Special case**: At the FIRST merge target, there's no prior merge-forward
branch, so merge the original PR commit SHA directly

### Branch Creation: Always Based on TARGET

Both `merge-forward` and `merge-conflicts` branches are created from the
**target** branch (its `branch-here` pointer), not the source. This ensures
we merge the PR's few commits INTO the target.

- `merge-forward-pr-123-release-5-8-0` → based on `branch-here-release-5.8.0`
- `merge-conflicts-999-release-5-8-0-to-main` → based on `main`

## Design Rationale: Why So Many Branches?

The merge-forward design creates many branches because **branches are how Git
tracks parallel histories**. There's no way to have User A's merge chain and
User B's merge chain exist simultaneously, in isolation, with preserved history,
without separate branches.

The branch proliferation isn't accidental complexity—it's the minimum structure
required to achieve **isolation + history preservation + parallelism**.

For alternatives considered and rejected, see [this comment on issue #3](https://github.com/SpiderStrategies/merge-bot/issues/3#issuecomment-3723369938).

## GitHub Action

The merge bot is a single consolidated GitHub Action that runs two phases:

**Phase 1: Auto-merge**
- Creates merge-forward branches for each PR
- Merges forward through the release branch chain using branch-here snapshots
- Creates conflict issues and merge-conflicts branches when conflicts occur

**Phase 2: Branch Maintenance**
- Updates branch-here pointers to the latest commit that reached main
- Updates release branches after successful merge-forward chains complete
- Cleans up completed merge-forward and merge-conflicts branches
- Ensures developers never inherit conflicts from earlier in the chain

## Repository Structure

```
merge-bot/
├── src/
│   ├── merge-bot.js              # Entry point - orchestrates both phases
│   ├── automerge.js              # Phase 1: Merge forward logic
│   ├── branch-maintainer.js      # Phase 2: Branch-here maintenance
│   ├── issue-resolver.js         # Creates conflict resolution issues
│   ├── find-clean-merge-ref.js   # Finds safe merge points
│   └── constants.js              # Shared constants
├── test/                         # Test files
├── dist/index.js                 # Bundled output (built with ncc)
└── action.yml                    # GitHub Action definition
```

## Configuration

- Config file: `.spider-merge-bot-config.json` (in default branch of Spider Impact repo)
- Defines release branches and merge operations
- Updated when new release branches are created

## Usage

The action is used in Spider Impact's workflow:

```yaml
- uses: SpiderStrategies/private-action-loader@master
  with:
    pal-repo-token: ${{ secrets.SPIDER_PAT }}
    pal-repo-name: SpiderStrategies/merge-bot@main
    config-file: config.json
    repo-token: ${{ secrets.SPIDER_PAT }}
```

It triggers on PR close and automatically handles both merge-forward and branch-here maintenance.

**Note on Git Hooks**: Spider Impact has pre-push hooks that run linters (semgrep,
ESLint, SCSS checks). These hooks do NOT affect the merge bot because the action
runs on GitHub's runners where hooks aren't installed. However, if you use
`manual-merge.sh` for recovery, it runs locally where your hooks ARE active—any
linter violations will block the push, which is expected behavior for manual
operations.

## Making Changes

1. Make changes to the code in `src/`
2. Run tests: `npm test`
3. Commit your changes to `src/` (no need to build or commit `dist/`)
4. Push to the `main` branch (or create a PR)
5. A GitHub Action will automatically:
   - Run tests again
   - Build `dist/index.js` using `npm run build`
   - Commit the updated `dist/` folder
6. Changes take effect immediately - Spider Impact references `@main`

## Related Issues

- Original implementation: #42921
- Improved branch-here updates: #68703, #63954
- Conflict isolation with merge-forward branches: #3
